<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>Ash and Blood</title>


<style>
/* ---------------------------------------------------------------------------
[000] STYLES (BG RESET — NO TITLE LOGO)
--------------------------------------------------------------------------- */
:root{
  --curtain-ms: 0ms;
  --curtain-delay-ms: 500ms;

  /* Background / Title fade timing */
  --bg-delay-ms: 0ms;      /* only used if you add transition-delay */
  --bg-in-ms: 6000ms;

  /* Title uses the SAME fade as background (sync as one piece) */
  --title-delay-ms: 0ms;   /* keep 0 so bg+title start together */
  --title-in-ms: var(--bg-in-ms);

  /* Menu */
  --menu-delay-ms: 3950ms;    /* only used if you add transition-delay */
  --menu-in-ms: 2000ms;
}

html,body{
  margin:0;
  padding:0;
  background:#000;
  overflow:hidden;
  touch-action:none;
  font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial;
  color:#dfe7ff;
}

/* Canvas fade control (prevents gameplay pop-in later) */
canvas{
  display:block;
  opacity:0;
  transition: opacity var(--bg-in-ms) cubic-bezier(0.2, 0.0, 0.2, 1);
}
canvas.show{ opacity:1; }

#hud,#pad-left,#pad-right,#modeBtn,#fireBtn{opacity:0;pointer-events:none;}

/* Curtain (short, cinematic, prevents flash) */
#curtain{
  position:fixed;
  inset:0;
  background:#000;
  z-index:20000;
  opacity:1;
  pointer-events:none;
  transition: opacity var(--curtain-ms) linear var(--curtain-delay-ms);

}
#curtain.off{opacity:0;}

/* TitleScreen container fades as ONE piece (bg + any title you add later) */
#titleScreen{
  position:fixed;
  inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  text-align:center;
  z-index:15000;

  opacity:0;
  pointer-events:none;
  padding:0;

  /* Use the long mood-light fade here */
  transition: opacity var(--bg-in-ms) cubic-bezier(0.2, 0.0, 0.2, 1);
}

#titleScreen.show{
  opacity:1;
  pointer-events:auto;
}

/* Background layer (does NOT fade separately; parent controls fade) */
#titleScreen::before{
  content:"";
  position:absolute;
  inset:0;
  z-index:0;
  background-repeat:no-repeat;
  background-position:center;
  background-size:cover;

  background-image: url('img/background.png');
}


#titleCard{
  position:relative;
  z-index:1;
  width:100%;
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  gap:14px;
  padding:0;
}

#titleLogo{
  display:block;
  position:relative;
  z-index:2;

  width: min(100vw, 1200px);
  height:auto;

  margin:-15vh auto 4vh auto;

  pointer-events:none;
  background:transparent;
  filter: drop-shadow(0 14px 34px rgba(0,0,0,.6));
}

#mainMenu{
  margin:0;
  display:flex;
  flex-direction:column;
  gap:14px;
  opacity:0;
  transition: opacity var(--menu-in-ms) cubic-bezier(0.2, 0.0, 0.2, 1);
  transition-delay: var(--menu-delay-ms);
  pointer-events:none;
}
#mainMenu.show{opacity:1;pointer-events:auto;}

.menu-btn{
  width:min(520px,84vw);margin:0 auto;
  padding:14px 16px;border-radius:12px;
  background:rgba(18,24,34,.42);
  border:1px solid rgba(255,255,255,.16);
  color:#e9f0ff;font-weight:800;
  letter-spacing:.08em;text-transform:uppercase;
  backdrop-filter:blur(6px);
}
.menu-btn:active{transform:scale(.99);opacity:.92;}

#bootScreen{
  position:fixed; inset:0;
  background:#000;
  z-index:25000;
  display:flex;
  align-items:center;
  justify-content:center;
}

#bootScreen.off{ display:none; }

/* ---------------------------------------------------------------------------
[000.5] BOOT SCREEN STYLES
--------------------------------------------------------------------------- */
#bootScreen{
  position:fixed;
  inset:0;
  background:#000;
  z-index:25000;
  display:flex;
  align-items:center;
  justify-content:center;
}

#bootScreen.off{
  display:none;
}

/* ---------------------------------------------------------------------------
[000.6] SAVE SLOTS PANEL STYLES
--------------------------------------------------------------------------- */
#slotModal{
  position:fixed;
  inset:0;
  z-index:18000;
  display:none;
}
#slotModal.show{ display:block; }

#slotModal .slot-backdrop{
  position:absolute; inset:0;
  background:rgba(0,0,0,.55);
  backdrop-filter: blur(6px);
}

#slotModal .slot-panel{
  position:absolute;
  left:50%; top:50%;
  transform:translate(-50%,-50%);
  width:min(560px, 92vw);
  padding:18px;
  border-radius:14px;
  background:rgba(14,18,26,.86);
  border:1px solid rgba(255,255,255,.14);
  box-shadow:0 18px 60px rgba(0,0,0,.6);
}

.slot-title{
  font-weight:900;
  letter-spacing:.08em;
  text-transform:uppercase;
  text-align:center;
  margin-bottom:12px;
}

.slot-subtitle{
  font-weight:800;
  letter-spacing:.06em;
  text-transform:uppercase;
  text-align:center;
  margin:10px 0 8px 0;
  opacity:.95;
}

#slotList{
  display:flex;
  flex-direction:column;
  gap:10px;
  margin:10px 0 14px 0;
}

.slot-empty{
  text-align:center;
  opacity:.75;
  padding:12px 0;
  font-weight:700;
}

#nameBlock, #actionBlock, #confirmDelete{
  display:none;
}

#nameInput{
  width:100%;
  box-sizing:border-box;
  padding:14px 14px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.16);
  background:rgba(0,0,0,.25);
  color:#e9f0ff;
  font-weight:800;
  letter-spacing:.04em;
  outline:none;
}

.slot-row{
  display:flex;
  gap:12px;
  margin-top:10px;
}
.slot-row .menu-btn{
  width:100%;
}


/* ---------------------------------------------------------------------------
[000.8] UI: LOAD SAVE PANEL (modal textbox)
--------------------------------------------------------------------------- */
#loadModal{
  position:fixed;
  inset:0;
  z-index:26000;
  display:none;          /* hidden by default */
  align-items:center;
  justify-content:center;
  padding:18px;
}

#loadModal.show{ display:flex; }

#loadModal .backdrop{
  position:absolute;
  inset:0;
  background:rgba(0,0,0,.62);
}

#loadModal .panel{
  position:relative;
  z-index:1;
  width:min(640px, 92vw);
  max-height:min(70vh, 620px);
  overflow:auto;
  border-radius:14px;
  background:rgba(12,16,22,.88);
  border:1px solid rgba(255,255,255,.14);
  box-shadow:0 22px 60px rgba(0,0,0,.55);
  backdrop-filter: blur(10px);
  padding:16px;
}

#loadModal .title{
  font-weight:900;
  letter-spacing:.08em;
  text-transform:uppercase;
  margin:6px 0 12px 0;
}

#saveList{
  display:flex;
  flex-direction:column;
  gap:10px;
}

.save-item{
  width:100%;
  text-align:left;
  padding:12px 12px;
  border-radius:12px;
  background:rgba(18,24,34,.42);
  border:1px solid rgba(255,255,255,.16);
  color:#e9f0ff;
  font-weight:800;
  letter-spacing:.04em;
}

.save-item:active{ transform:scale(.99); opacity:.92; }

.save-empty{
  padding:12px;
  border-radius:12px;
  background:rgba(255,255,255,.06);
  border:1px dashed rgba(255,255,255,.18);
  color:rgba(233,240,255,.75);
}

#btnCloseLoad{
  margin-top:12px;
  width:100%;
}


</style>

</head>

<body>

<div id="curtain"></div>

<!-- ---------------------------------------------------------------------------
[H000] BOOT SCREEN (sound unlock)
--------------------------------------------------------------------------- -->
<div id="bootScreen">
  <button id="bootStartBtn" class="menu-btn">START</button>
</div>

<!-- ---------------------------------------------------------------------------
[H001] TITLE SCREEN + MAIN MENU (single unified screen)
--------------------------------------------------------------------------- -->
<div id="titleScreen">
  <div id="titleCard">
    <img id="titleLogo" alt="ASH AND BLOOD" src="img/title.png">

    <!-- MAIN MENU -->
    <div id="mainMenu">
      <button id="btnNew" class="menu-btn">START GAME</button>
      <button id="btnOptions" class="menu-btn">OPTIONS</button>
    </div>
  </div>
</div>


<!-- ---------------------------------------------------------------------------
[H002] SAVE SLOTS PANEL (textbox)
--------------------------------------------------------------------------- -->
<div id="slotModal" aria-label="Save Slots Panel">
  <div class="slot-backdrop"></div>

  <div class="slot-panel">
    <div class="slot-title" id="slotTitle">CHOOSE SAVE SLOT</div>

    <div id="slotList"></div>

    <!-- Name Survivor (hidden until needed) -->
    <div id="nameBlock">
      <div class="slot-subtitle">NAME SURVIVOR</div>
      <input id="nameInput" type="text" maxlength="16" placeholder="Enter name..." />
      <div class="slot-row">
        <button id="btnNameConfirm" class="menu-btn">CONFIRM</button>
        <button id="btnNameCancel" class="menu-btn">CANCEL</button>
      </div>
    </div>

    <!-- Slot Actions (hidden until needed) -->
    <div id="actionBlock">
      <div class="slot-row">
        <button id="btnLoadSlot" class="menu-btn">LOAD SAVE</button>
        <button id="btnDeleteSlot" class="menu-btn">DELETE SAVE</button>
      </div>

      <div id="confirmDelete">
        <div class="slot-subtitle">ARE YOU SURE?</div>
        <div class="slot-row">
          <button id="btnDeleteYes" class="menu-btn">YES</button>
          <button id="btnDeleteNo" class="menu-btn">NO</button>
        </div>
      </div>
    </div>

    <button id="btnCloseSlots" class="menu-btn">CLOSE</button>
  </div>
</div>


<!-- ---------------------------------------------------------------------------
[H003] GAMEPLAY UI + CANVAS (hidden until game starts)
--------------------------------------------------------------------------- -->

<div id="hud">
  <div class="hud-pill">HP <span id="hp">100</span></div>
  <div class="hud-pill">LV <span id="lv">1</span></div>
</div>

<div id="pad-left" class="pad"><div class="stick"></div></div>
<div id="pad-right" class="pad"><div class="stick"></div></div>

<div id="modeBtn">AUTO FIRE</div>
<div id="fireBtn">FIRE</div>

<canvas id="game"></canvas>

<script>
/* ---------------------------------------------------------------------------
[001] UTIL: seeded RNG
--------------------------------------------------------------------------- */
function RNG(seed){
  this.s=seed>>>0
}
RNG.prototype.next=function(){
  this.s=(this.s*1664525+1013904223)>>>0
  return this.s/4294967296
}

/* ---------------------------------------------------------------------------
[002] CANVAS + CAMERA
--------------------------------------------------------------------------- */
const canvas=document.getElementById('game')
const ctx=canvas.getContext('2d')
function resize(){
  canvas.width=innerWidth
  canvas.height=innerHeight
}
addEventListener('resize',resize)
resize()

const camera={x:0,y:0,zoom:1}

/* ---------------------------------------------------------------------------
[003] INPUT: virtual sticks
--------------------------------------------------------------------------- */
function Stick(el){
  this.el=el
  this.knob=el.querySelector('.stick')
  this.active=false
  this.dx=0; this.dy=0
  el.addEventListener('pointerdown',e=>{
    this.active=true
    this.ox=e.clientX; this.oy=e.clientY
  })
  addEventListener('pointermove',e=>{
    if(!this.active) return
    let x=e.clientX-this.ox
    let y=e.clientY-this.oy
    const d=Math.hypot(x,y)
    if(d>40){x*=40/d;y*=40/d}
    this.dx=x/40; this.dy=y/40
    this.knob.style.transform=`translate(${x}px,${y}px)`
  })
  addEventListener('pointerup',()=>{
    this.active=false
    this.dx=this.dy=0
    this.knob.style.transform='translate(0,0)'
  })
}
const moveStick=new Stick(document.getElementById('pad-left'))
const aimStick=new Stick(document.getElementById('pad-right'))

/* ---------------------------------------------------------------------------
[004] WORLD: procedural outdoor map
--------------------------------------------------------------------------- */
const TILE=96
const MAP_W=20, MAP_H=20
const world=[]
const rng=new RNG(12345)

for(let y=0;y<MAP_H;y++){
  for(let x=0;x<MAP_W;x++){
    world.push({
      x,y,
      type:rng.next()<.1?'building':'street'
    })
  }
}

/* ---------------------------------------------------------------------------
[005] PLAYER
--------------------------------------------------------------------------- */
const player={
  x:MAP_W*TILE/2,
  y:MAP_H*TILE/2,
  a:0,
  hp:100
}

/* ---------------------------------------------------------------------------
[006] ENEMIES
--------------------------------------------------------------------------- */
const enemies=[]
for(let i=0;i<6;i++){
  enemies.push({
    x:rng.next()*MAP_W*TILE,
    y:rng.next()*MAP_H*TILE,
    a:rng.next()*Math.PI*2,
    state:'idle'
  })
}

/* ---------------------------------------------------------------------------
[007] UPDATE LOOP
--------------------------------------------------------------------------- */
let autoFire=true
const modeBtn=document.getElementById('modeBtn')
modeBtn.onclick=()=>{
  autoFire=!autoFire
  modeBtn.textContent=autoFire?'AUTO FIRE':'MANUAL'
}

function update(dt){
  // movement
  const spd=2
  if(moveStick.active){
    player.x+=moveStick.dx*spd*dt
    player.y+=moveStick.dy*spd*dt
    if(!aimStick.active){
      player.a=Math.atan2(moveStick.dy,moveStick.dx)
    }
  }
  if(aimStick.active){
    player.a=Math.atan2(aimStick.dy,aimStick.dx)
  }

  camera.x=player.x
  camera.y=player.y
}

/* ---------------------------------------------------------------------------
[008] RENDER
--------------------------------------------------------------------------- */
function draw(){
  ctx.setTransform(1,0,0,1,0,0)
  ctx.clearRect(0,0,canvas.width,canvas.height)

  ctx.translate(canvas.width/2,canvas.height/2)
  ctx.scale(camera.zoom,camera.zoom)
  ctx.translate(-camera.x,-camera.y)

  // tiles
  for(const t of world){
    ctx.fillStyle=t.type==='building'?'#2b3444':'#3a4558'
    ctx.fillRect(t.x*TILE,t.y*TILE,TILE,TILE)
  }

  // enemies
  for(const e of enemies){
    ctx.fillStyle='#6aff6a'
    ctx.beginPath()
    ctx.arc(e.x,e.y,14,0,Math.PI*2)
    ctx.fill()
  }

  // player
  ctx.save()
  ctx.translate(player.x,player.y)
  ctx.rotate(player.a)
  ctx.fillStyle='#dfe7ff'
  ctx.fillRect(-10,-14,20,28)
  ctx.fillStyle='#ff5555'
  ctx.fillRect(8,-3,10,6)
  ctx.restore()

  // vignette
  const g=ctx.createRadialGradient(
    camera.x,camera.y,200,
    camera.x,camera.y,800
  )
  g.addColorStop(0,'rgba(0,0,0,0)')
  g.addColorStop(1,'rgba(0,0,0,.6)')
  ctx.fillStyle=g
  ctx.fillRect(
    camera.x-1000,camera.y-1000,
    2000,2000
  )
}

/* ---------------------------------------------------------------------------
[009] TITLE FLOW + SAVE SLOTS (black -> title -> menu)
--------------------------------------------------------------------------- */

const titleScreen = document.getElementById('titleScreen');
const curtain     = document.getElementById('curtain');
const mainMenu    = document.getElementById('mainMenu');
const btnNew      = document.getElementById('btnNew');
const btnOptions  = document.getElementById('btnOptions');

/* SAVE SLOT UI ELEMENTS */
const slotModal      = document.getElementById('slotModal');
const slotBackdrop   = slotModal.querySelector('.slot-backdrop');
const slotTitle      = document.getElementById('slotTitle');
const slotList       = document.getElementById('slotList');
const btnCloseSlots  = document.getElementById('btnCloseSlots');

const nameBlock      = document.getElementById('nameBlock');
const nameInput      = document.getElementById('nameInput');
const btnNameConfirm = document.getElementById('btnNameConfirm');
const btnNameCancel  = document.getElementById('btnNameCancel');

const actionBlock    = document.getElementById('actionBlock');
const btnLoadSlot    = document.getElementById('btnLoadSlot');
const btnDeleteSlot  = document.getElementById('btnDeleteSlot');
const confirmDelete  = document.getElementById('confirmDelete');
const btnDeleteYes   = document.getElementById('btnDeleteYes');
const btnDeleteNo    = document.getElementById('btnDeleteNo');

/* YOU can change these later */
const SLOT_COUNT = 5;

/* Internal state */
let selectedSlot = null;

/* Helpers */
function slotKey(i){ return `AAB_SLOT_${i}`; }   // slot info (name, etc.)
function saveKey(i){ return `AAB_SAVE_${i}`; }   // actual save data
function getSlotName(i){
  const raw = localStorage.getItem(slotKey(i));
  if(!raw) return null;
  try{
    const obj = JSON.parse(raw);
    return obj && obj.name ? obj.name : null;
  }catch(e){
    return null;
  }
}
function slotHasSave(i){
  return !!localStorage.getItem(saveKey(i));
}

/* UI show/hide */
function openSlots(){
  selectedSlot = null;
  slotTitle.textContent = 'CHOOSE SAVE SLOT';
  nameBlock.style.display = 'none';
  actionBlock.style.display = 'none';
  confirmDelete.style.display = 'none';

  rebuildSlotList();

  slotModal.classList.add('show');
}
function closeSlots(){
  slotModal.classList.remove('show');
  nameInput.value = '';
  selectedSlot = null;
}
function showNamePrompt(slotNum){
  selectedSlot = slotNum;
  slotTitle.textContent = `NEW GAME — SLOT ${slotNum}`;
  nameBlock.style.display = 'block';
  actionBlock.style.display = 'none';
  confirmDelete.style.display = 'none';
  nameInput.value = '';
  setTimeout(()=>nameInput.focus(), 50);
}
function showActions(slotNum){
  selectedSlot = slotNum;
  const nm = getSlotName(slotNum) || `SLOT ${slotNum}`;
  slotTitle.textContent = `${nm}`;
  nameBlock.style.display = 'none';
  actionBlock.style.display = 'block';
  confirmDelete.style.display = 'none';
}

/* Build list */
function rebuildSlotList(){
  slotList.innerHTML = '';

  let any = false;

  for(let i=1;i<=SLOT_COUNT;i++){
    const nm = getSlotName(i);
    const label = nm ? nm : '---New Game---';

    const row = document.createElement('button');
    row.className = 'menu-btn';
    row.textContent = `${i}  ${label}`;

    row.addEventListener('click', ()=>{
      if(nm && slotHasSave(i)){
        showActions(i);
      }else{
        showNamePrompt(i);
      }
    });

    slotList.appendChild(row);

    if(nm || slotHasSave(i)) any = true;
  }

  // If literally nothing exists yet, show a hint line inside the box
  if(!any){
    const msg = document.createElement('div');
    msg.className = 'slot-empty';
    msg.textContent = 'No saves available';
    slotList.appendChild(msg);
  }
}

/* Start game after slot chosen */
function beginGameForSlot(slotNum){
  // Hide menus
  closeSlots();
  titleScreen.classList.remove('show');
  mainMenu.classList.remove('show');

  // Start gameplay (your existing function)
  startGameplay();
}

/* Create new game */
btnNameConfirm.addEventListener('click', ()=>{
  if(!selectedSlot) return;

  const name = (nameInput.value || '').trim();
  if(!name){
    alert('Please enter a name');
    return;
  }

  // Store slot meta
  localStorage.setItem(slotKey(selectedSlot), JSON.stringify({
    name,
    createdAt: Date.now()
  }));

  // Create a starter save (minimal for now; we expand later)
  localStorage.setItem(saveKey(selectedSlot), JSON.stringify({
    v: 1,
    name,
    createdAt: Date.now()
  }));

  beginGameForSlot(selectedSlot);
});

btnNameCancel.addEventListener('click', ()=>{
  selectedSlot = null;
  nameBlock.style.display = 'none';
  slotTitle.textContent = 'CHOOSE SAVE SLOT';
});

/* Load / Delete */
btnLoadSlot.addEventListener('click', ()=>{
  if(!selectedSlot) return;

  const raw = localStorage.getItem(saveKey(selectedSlot));
  if(!raw){
    alert('No saved game found');
    return;
  }

  // Later: we will actually apply saved state here.
  // For now: it still enters the game so you can confirm flow works.
  beginGameForSlot(selectedSlot);
});

btnDeleteSlot.addEventListener('click', ()=>{
  confirmDelete.style.display = 'block';
});

btnDeleteYes.addEventListener('click', ()=>{
  if(!selectedSlot) return;

  localStorage.removeItem(saveKey(selectedSlot));
  localStorage.removeItem(slotKey(selectedSlot));

  selectedSlot = null;
  confirmDelete.style.display = 'none';
  nameBlock.style.display = 'none';
  actionBlock.style.display = 'none';
  slotTitle.textContent = 'CHOOSE SAVE SLOT';
  rebuildSlotList();
});

btnDeleteNo.addEventListener('click', ()=>{
  confirmDelete.style.display = 'none';
});

/* Close modal */
btnCloseSlots.addEventListener('click', closeSlots);
slotBackdrop.addEventListener('click', closeSlots);

/* START GAME opens slots */
btnNew.addEventListener('click', openSlots);

/* OPTIONS placeholder for now */
if(btnOptions){
  btnOptions.addEventListener('click', ()=>{
    alert('Options coming next');
  });
}

/* Existing title sequence */
function runTitleSequence(){
  const BLACK_HOLD_MS = 2000;
  const TITLE_HOLD_MS = 5000;

  curtain.classList.remove('off');
  titleScreen.classList.remove('show');
  mainMenu.classList.remove('show');

  setTimeout(()=>{
    titleScreen.classList.add('show');
    curtain.classList.add('off');

    setTimeout(()=>{
      mainMenu.classList.add('show');
    }, TITLE_HOLD_MS);

  }, BLACK_HOLD_MS);
}





/* ---------------------------------------------------------------------------
[010] GAME LOOP (disabled until later phases)
--------------------------------------------------------------------------- */
function startGameplay(){
  const canvas = document.getElementById('game');

  // reveal gameplay only when this is explicitly called
  canvas.classList.add('show');

  let last = 0;
  function loop(t){
    const dt = (t - last) / 16;
    last = t;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
}

/* ---------------------------------------------------------------------------
[011] AUDIO: BOOT SCREEN → MENU MUSIC (delay + gain fade, no pop, no cut)
--------------------------------------------------------------------------- */

/* FILE PATH (matches your repo structure) */
const MENU_MUSIC_SRC = 'audio/menu.mp3';

/* YOU control these */
const MENU_MUSIC_BASE_GAIN      = 0.50;  // 0.0–1.0 (master volume)
const MENU_MUSIC_AUDIBLE_DELAY  = 1500;   // ms after visuals begin
const MENU_MUSIC_FADEIN_MS      = 0;  // ms fade-in duration

let audioCtx = null;
let menuBuf = null;
let menuSrc = null;
let menuGain = null;

/* Create / resume AudioContext ONLY on user gesture */
function ensureAudio(){
  const AC = window.AudioContext || window.webkitAudioContext;
  if(!AC) return false;
  if(!audioCtx) audioCtx = new AC();
  return true;
}

/* Load + decode once (prevents “intro cut off”) */
async function loadMenuBuffer(){
  if(menuBuf) return;
  const res = await fetch(MENU_MUSIC_SRC, { cache:'no-store' });
  if(!res.ok) throw new Error('fetch failed: ' + res.status);
  const ab = await res.arrayBuffer();
  menuBuf = await audioCtx.decodeAudioData(ab);
}

/* Start playing immediately at gain=0, then fade in after delay */
function startMenuMusic(){
  if(!menuBuf) return;

  // Stop existing if any (avoid overlaps)
  try { menuSrc && menuSrc.stop(); } catch(e){}
  menuSrc = audioCtx.createBufferSource();
  menuSrc.buffer = menuBuf;
  menuSrc.loop = true;

  if(!menuGain){
    menuGain = audioCtx.createGain();
    menuGain.connect(audioCtx.destination);
  }

  // Start silent (prevents pop/crackle)
  const now = audioCtx.currentTime;
  menuGain.gain.cancelScheduledValues(now);
  menuGain.gain.setValueAtTime(0.0, now);

  menuSrc.connect(menuGain);
  menuSrc.start(0);

  // After delay, fade up smoothly (gain ramp, not HTMLAudio volume)
  setTimeout(()=>{
    const t0 = audioCtx.currentTime;
    menuGain.gain.cancelScheduledValues(t0);
    menuGain.gain.setValueAtTime(menuGain.gain.value, t0);
    menuGain.gain.linearRampToValueAtTime(
      MENU_MUSIC_BASE_GAIN,
      t0 + (MENU_MUSIC_FADEIN_MS / 1000)
    );
  }, MENU_MUSIC_AUDIBLE_DELAY);
}

/* This is called by the START button */
async function startMenuSequence(){
  if(!ensureAudio()) return;

  try { await audioCtx.resume(); } catch(e){}

  // Remove boot screen first (optional order), then start visuals
  const boot = document.getElementById('bootScreen');
  if(boot) boot.classList.add('off');

  // Start your title/background fade sequence (visuals begin here)
  runTitleSequence();

  // Load music (if not loaded) then start music (silent→fade)
  try{
    await loadMenuBuffer();
    startMenuMusic();
  }catch(e){
    // If audio fails, continue visuals anyway (silent)
  }
}

/* Bind START button (one event is enough) */
const bootBtn = document.getElementById('bootStartBtn');
if(bootBtn){
  bootBtn.addEventListener('click', startMenuSequence, { once:true });
}



</script>
</body>
</html>
